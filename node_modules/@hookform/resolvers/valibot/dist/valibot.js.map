{"version":3,"file":"valibot.js","sources":["../src/valibot.ts"],"sourcesContent":["import { toNestErrors } from '@hookform/resolvers';\nimport { FieldError, appendErrors, FieldValues } from 'react-hook-form';\nimport { getDotPath, safeParseAsync } from 'valibot';\nimport type { Resolver } from './types';\n\nexport const valibotResolver: Resolver =\n  (schema, schemaOptions, resolverOptions = {}) =>\n  async (values, _, options) => {\n    // Check if we should validate all field criteria\n    const validateAllFieldCriteria =\n      !options.shouldUseNativeValidation && options.criteriaMode === 'all';\n\n    // Parse values with Valibot schema\n    const result = await safeParseAsync(schema, values, {\n      ...schemaOptions,\n      abortPipeEarly: !validateAllFieldCriteria,\n    });\n\n    // If there are issues, return them as errors\n    if (result.issues) {\n      // Create errors object\n      const errors: Record<string, FieldError> = {};\n\n      // Iterate over issues to add them to errors object\n      for (const issue of result.issues) {\n        // Create dot path from issue\n        const path = getDotPath(issue);\n\n        if (path) {\n          // Add first error of path to errors object\n          if (!errors[path]) {\n            errors[path] = { message: issue.message, type: issue.type };\n          }\n\n          // If configured, add all errors of path to errors object\n          if (validateAllFieldCriteria) {\n            const types = errors[path].types;\n            const messages = types && types[issue.type];\n            errors[path] = appendErrors(\n              path,\n              validateAllFieldCriteria,\n              errors,\n              issue.type,\n              messages\n                ? ([] as string[]).concat(\n                    messages as string | string[],\n                    issue.message,\n                  )\n                : issue.message,\n            ) as FieldError;\n          }\n        }\n      }\n\n      // Return resolver result with errors\n      return {\n        values: {},\n        errors: toNestErrors(errors, options),\n      } as const;\n    }\n\n    // Otherwise, return resolver result with values\n    return {\n      values: resolverOptions.raw ? values : (result.output as FieldValues),\n      errors: {},\n    };\n  };\n"],"names":["schema","schemaOptions","resolverOptions","values","_","options","validateAllFieldCriteria","shouldUseNativeValidation","criteriaMode","Promise","resolve","safeParseAsync","_extends","abortPipeEarly","then","result","issues","_step","errors","_iterator","_createForOfIteratorHelperLoose","done","issue","value","path","getDotPath","message","type","types","messages","appendErrors","concat","toNestErrors","raw","output","e","reject"],"mappings":"6bAME,SAACA,EAAQC,EAAeC,GAAoB,YAApBA,IAAAA,IAAAA,EAAkB,CAAE,GAAA,SACrCC,EAAQC,EAAGC,GAAO,IAEvB,IAAMC,GACHD,EAAQE,2BAAsD,QAAzBF,EAAQG,aAAuB,OAAAC,QAAAC,QAGlDC,EAAcA,eAACX,EAAQG,EAAMS,EAAA,CAAA,EAC7CX,EAAa,CAChBY,gBAAiBP,MACjBQ,KAAA,SAHIC,GAMN,GAAIA,EAAOC,OAAQ,CAKjB,IAHA,IAGiCC,EAH3BC,EAAqC,CAAE,EAG7CC,2qBAAAC,CAAoBL,EAAOC,UAAMC,EAAAE,KAAAE,MAAE,KAAxBC,EAAKL,EAAAM,MAERC,EAAOC,EAAUA,WAACH,GAExB,GAAIE,IAEGN,EAAOM,KACVN,EAAOM,GAAQ,CAAEE,QAASJ,EAAMI,QAASC,KAAML,EAAMK,OAInDrB,GAA0B,CAC5B,IAAMsB,EAAQV,EAAOM,GAAMI,MACrBC,EAAWD,GAASA,EAAMN,EAAMK,MACtCT,EAAOM,GAAQM,EAAAA,aACbN,EACAlB,EACAY,EACAI,EAAMK,KACNE,EACK,GAAgBE,OACfF,EACAP,EAAMI,SAERJ,EAAMI,QAEb,CAEJ,CAGD,MAAO,CACLvB,OAAQ,GACRe,OAAQc,EAAAA,aAAad,EAAQb,GAEhC,CAGD,MAAO,CACLF,OAAQD,EAAgB+B,IAAM9B,EAAUY,EAAOmB,OAC/ChB,OAAQ,CAAA,EACR,EACJ,CAAC,MAAAiB,GAAA1B,OAAAA,QAAA2B,OAAAD,EAAA,CAAA,CAAA"}